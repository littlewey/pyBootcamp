[
{
	"uri": "http://pyCamp.swdp.me/tasks/task-1/",
	"title": "Build a web Tool",
	"tags": [],
	"description": "",
	"content": "This task is to create a web app with flask, following the flask-mega-tutorial first three chapters.\nreference:\n innoSearch project: https://github.com/littlewey/yet-another-GSC-C-lighthouse ldif-compare: https://github.com/littlewey/ldif-compare  After class task:\n create a web tool, which could reuse the main function of Task 0.  "
},
{
	"uri": "http://pyCamp.swdp.me/tasks/task-2/",
	"title": "Build a blockchain",
	"tags": [],
	"description": "",
	"content": "  Our task demo is highly reusing code and even some words in https://hackernoon.com/learn-blockchains-by-building-one-117428612f46 (many thanks to Daniel van Flymen), some enhancements were added on top of that here including sender address verification, and some script clients.\n In this task, we will create a simple part of blockchain application like bitcoin.\nThings we will go though:\n Some object-oriented coding (not just call class from a python module) http request flask as http api endpoints  [TOC]\n1. What is a blockchain looks like  ref: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses\nref: https://en.bitcoin.it/wiki/Protocol_rules\nref: https://www.zhihu.com/question/20941124\nref: https://www.youtube.com/watch?v=Lx9zgZCMqXE\n The thing here we will build is a tiny version of the very first blockchain: bitcoin. We could see what a bitcoin block looks like here: https://blockchain.info .\n1.1 Concepts  Block\n Things inside: index hash of last block timestamp transactions nonce Things could be done:  hash ( to solve puzzle and output the nonce and hash value) validation ( check if the chain/block is valid ) create new block to the chain add new transaction to transaction pool   Wallet\n address ( a public key, for transaction verification and showing identity/ ownership ) secret ( a private key for signing transactions, with it you could spend/withdraw your wallet) Things need to be done: sign verify  node\n broadcast and recieve other nodes broadcast to: get longest valid blockchain recieve transaction, verify ownership send transaction send mining outcome transaction mining guess proof of work(nonce) the solve puzzle with last block on the chain and valid transactions in pool   2. Blueprint of the code $ tree -L 1 . ├── blockchain.py ├── node.py ├── sigScript.py └── wallet.py  2.1 blockchain.py For blockchain, we need to implement a class with below things, and it will be called by node or so:\nclass Blockchain: def __init__(self): self.chain = [] self.transactionsPool = [] def new_block(self): # build a new Block and adds it to the chain pass def new_transaction_by_mining(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass  note, @staticmethod is function that need to be reused internal and external the class, which are not related to instance( the self), also calling it won\u0026rsquo;t trigger __init__.\nexample:\nIn [104]: class MyClass: ...: def __init__(self): ...: print(\u0026quot;Initialize instance - not used\u0026quot;) ...: ...: @staticmethod ...: def my_static(toprint): ...: print(toprint) ...: In [105]: MyClass.my_static(\u0026quot;Print this\u0026quot;) Print this  note, @property is to make the method to be a getter, it means blockchainInstance.last_block could be called.\n2.2 wallet.py For wallet, we need to implement class with below things, and it will be called by node and signatureScript:\nclass Wallet: def __init__(self): # generated a new key pair self.publicKey = \u0026quot;\u0026quot; self.privateKey = \u0026quot;\u0026quot; @property def address(self): return self.publicKey @property def secret(self): return self.privateKey def signature(self, hashedTransaction): # sign the hashedTransaction with privateKey, return the signature pass @staticmethod def verification(transaction, publickey, signature): # verify a given transaction with publickey(sender's address) and signature to verify ownership pass  2.3 node.py For node, it\u0026rsquo;s the running machine calling and being called :\n by neighbor nodes for communications by user for querying data/status and requesting for transactions by owner for mining  etc.\nWe used a simpfied and already known solution: http API server, provided by flask.\n2.3.1 Endpoints Endpoints to be implemented.\n Implemente them in step one\n  /mine /transactions /transactions/new /chain   Implemeted later\n  /nodes /nodes/register /nodes/resolve  from blockchain import Blockchain from wallet import Wallet from flask import Flask, jsonify, request # Instantiate the Node app = Flask(__name__) # Instantiate the Wallet wallet = Wallet() # Instantiate the Blockchain blockchain = Blockchain() # endpoints @app.route('/mine', methods=['GET']) def mine(): return \u0026quot;We'll mine a new Block\u0026quot; @app.route('/transactions/new', methods=['POST']) def new_transaction(): return \u0026quot;We'll add a new transaction\u0026quot; @app.route('/chain', methods=['GET']) def full_chain(): response = { 'chain': blockchain.chain, 'length': len(blockchain.chain), } return jsonify(response), 200 if __name__ == '__main__': app.run(host='0.0.0.0', port=5000)  2.4 sigScript.py This is a cli tool to sign a transaction, we are going to call it by some bash client for user to request transactions. We could talk about it later together with wallet.py .\n\u0026quot;\u0026quot;\u0026quot; Usage: singnagureScript.py transaction privateKey Options: --help Show this help screen \u0026quot;\u0026quot;\u0026quot; import sys from Crypto.Hash import MD5 from wallet import Wallet transaction, privateKey = [ argument.encode() for argument in argv[1:] ] hashedTransaction = MD5.new(transaction) wallet = Wallet(privateKeyB64 = privateKeyB64) signature = wallet.signature(hashedTransaction) print (signature)  3. Start with blockchain.py 3.1 glance of Block Each Block has an index, a timestamp (in Unix time), a list of transactions, a proof (more on that later), and the hash of the previous Block.\nHere’s an example of what a single Block looks like:\nThe previous_hash is the hash value of the block with index: index - 1 , and that\u0026rsquo;s how the chain connected and that’s what gives blockchains immutability: If an attacker corrupted an earlier Block in the chain then all subsequent blocks will contain incorrect hashes.\nblock = { 'index': 1, 'timestamp': 1506057125.900785, 'transactions': [ { 'sender': \u0026quot;8527147fe1f5426f9dd545de4b27ee00\u0026quot;, 'recipient': \u0026quot;a77f5cdfa2934df3954a5c7c7da5df1f\u0026quot;, 'amount': 5, } ], 'proof': 324984774000, 'previous_hash': \u0026quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\u0026quot; }  3.2 Transaction self.transactionsPool is a list of transactions to be added in next mined block. And it looks like this:\n{ \u0026quot;sender\u0026quot;: \u0026quot;my address\u0026quot;, \u0026quot;recipient\u0026quot;: \u0026quot;someone else's address\u0026quot;, \u0026quot;amount\u0026quot;: 5 }  Then method new_transaction(self, sender, recipient, amount) could be like this:\nIt actually appends a the transaction as a new dict to the list transactionsPool.\nThis method should be called on two conditions:\n mining wallet owner (user) triggerred transaction  We\u0026rsquo;ll implement that later on corresponding endpoints in node.py\nclass Blockchain: #... def new_transaction(self, sender, recipient, amount): \u0026quot;\u0026quot;\u0026quot; Creates a new transaction to go into the next mined Block :param sender: \u0026lt;str\u0026gt; Address of the Sender :param recipient: \u0026lt;str\u0026gt; Address of the Recipient :param amount: \u0026lt;int\u0026gt; Amount :return: \u0026lt;int\u0026gt; The index of the Block that will hold this transaction \u0026quot;\u0026quot;\u0026quot; self.transactionsPool.append({ 'sender': sender, 'recipient': recipient, 'amount': amount, })  3.3 Build block When our Blockchain is instantiated we’ll need to seed it with a genesis block—a block with no predecessors. We’ll also need to add a proof to our genesis block which is the result of mining (or proof of work). We’ll talk more about mining later.\nIn addition to creating the genesis block in our constructor, we’ll also flesh out the methods for new_block(), new_transaction() and hash():\nimport hashlib import json from time import time from urllib.parse import urlparse class Blockchain: def __init__(self): self.chain = [] self.transactionsPool = [] # Create the genesis block self.new_block(previous_hash=1, proof=1) def new_block(self, proof, previous_hash): \u0026quot;\u0026quot;\u0026quot; Create a new Block in the Blockchain :param proof: The proof given by the Proof of Work algorithm :param previous_hash: Hash of previous Block :return: New Block \u0026quot;\u0026quot;\u0026quot; block = { 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.transactionsPool, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), } # Reset the pool transactions self.transactionsPool = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): \u0026quot;\u0026quot;\u0026quot; Creates a new transaction to go into the next mined Block :param sender: Address of the Sender :param recipient: Address of the Recipient :param amount: Amount :return: The index of the Block that will hold this transaction \u0026quot;\u0026quot;\u0026quot; self.transactionsPool.append({ 'sender': sender, 'recipient': recipient, 'amount': amount, }) @staticmethod def hash(block): \u0026quot;\u0026quot;\u0026quot; Creates a SHA-256 hash of a Block :param block: Block \u0026quot;\u0026quot;\u0026quot; # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): # Returns the last Block in the chain pass  We’re almost done with representing our blockchain. But at this point, you must be wondering how new blocks are created or mined.\n3.4 Proof of Work (nonce) A Proof of Work algorithm (PoW) is how new Blocks are created or mined on the blockchain. The goal of PoW is to discover a number which solves a problem. The number must be difficult to find but easy to verify—computationally speaking—by anyone on the network. This is the core idea behind Proof of Work.\nWe’ll look at a very simple example to help this sink in.\nLet’s decide that the hash of some integer x multiplied by another y must end in 0. So, hash(x * y) = ac23dc...0. And for this simplified example, let’s fix x = 5. Implementing this in Python:\nfrom hashlib import sha256 x = 5 y = 0 # We don't know what y should be yet... while sha256(str(x*y).encode()).hexdigest()[-1] != \u0026quot;0\u0026quot;: y += 1 print(\u0026quot;The solution is y = %d \u0026quot; % y)  The solution here is y = 21. Since, the produced hash ends in 0:\nIn [1]: sha256(str(5 * 21).encode()).hexdigest() Out[1]: '1253e9373e781b7500266caa55150e08e210bc8cd8cc70d89985e3600155e860'  In Bitcoin, the Proof of Work algorithm is called Hashcash. And it’s not too different from our basic example above. It’s the algorithm that miners race to solve in order to create a new block. In general, the difficulty is determined by the number of characters searched for in a string. The miners are then rewarded for their solution by receiving a coin—in a transaction.\nThe network is able to easily verify their solution.\nLet\u0026rsquo;s make a diffculty configuration interface, create a file called config.py\ndifficulty = 4  Invoke it by import\nfrom config import difficulty  Let\u0026rsquo;s implementing the Proof of Work code:\nimport hashlib import json from time import time from urllib.parse import urlparse from config import difficulty #... def proof_of_work(self, last_block): \u0026quot;\u0026quot;\u0026quot; Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') contains leading \u0026lt;number of difficulty\u0026gt; zeroes - Where p is the previous proof, and p' is the new proof :param last_block: \u0026lt;dict\u0026gt; last Block :return: \u0026lt;int\u0026gt; \u0026quot;\u0026quot;\u0026quot; last_proof = last_block['proof'] last_hash = self.hash(last_block) proof = 0 while self.valid_proof(last_proof, proof, last_hash) is False: proof += 1 return proof @property def last_block(self): return self.chain[-1] @staticmethod def valid_proof(last_proof, proof, last_hash): \u0026quot;\u0026quot;\u0026quot; Validates the Proof :param last_proof: \u0026lt;int\u0026gt; Previous Proof :param proof: \u0026lt;int\u0026gt; Current Proof :param last_hash: \u0026lt;str\u0026gt; The hash of the Previous Block :return: \u0026lt;bool\u0026gt; True if correct, False if not. \u0026quot;\u0026quot;\u0026quot; guess = \u0026quot;\u0026quot;.join([str(last_proof),str(proof),last_hash]).encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:difficulty] == \u0026quot;0\u0026quot; * difficulty # ...  To adjust the difficulty of the algorithm, we could modify it in config.py. But 4 is sufficient. You’ll find out that the addition of a single leading zero makes a huge difference to the time required to find a solution.\nOur blockchain class is almost complete and we’re ready to begin interacting with it using HTTP requests.\n4. node.py , the mining node It\u0026rsquo;s designed like this:\n /mine minning a block /transactions get transaction pool /transactions/new issue a transaction /chain get whole chain /nodes get surrounding nodes /nodes/register register a neighbor node /nodes/resolve resolve blockchain conflic among nodes  4.1 /chain and/transactions API For /chain, we already have it even during the blueprint drawing.\nAs http server, it builds the dict format response than converts it to json, finally returns it to http client with 200 OK. The 'chain' value comes form the blockchain instance.\n ref: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n #... # Instantiate the Blockchain blockchain = Blockchain() #... @app.route('/chain', methods=['GET']) def full_chain(): response = { 'chain': blockchain.chain, 'length': len(blockchain.chain), } return jsonify(response), 200  Similarly /transactions could be like this:\n@app.route('/transactions', methods=['GET']) def all_transactions(): response = { 'transactions': blockchain.transactionsPool, 'length': len(blockchain.transactionsPool), } return jsonify(response), 200  4.2 /transactions/new API In bitcoin, miner should verify transactions in at least two parts:\n The ownership of sender, by signature verification The balance of a sender\u0026rsquo;s account, by track the chain of transactions. ( we don\u0026rsquo;t implement this part for now and thus we cannot know if sender has enough balance in our demo codes, sorry about that\u0026hellip; )  Then it should recieve like this:\n{ \u0026quot;sender\u0026quot;: \u0026quot;my address\u0026quot;, \u0026quot;recipient\u0026quot;: \u0026quot;someone else's address\u0026quot;, \u0026quot;amount\u0026quot;: 5, \u0026quot;signature\u0026quot;: \u0026quot;signature of my address\u0026quot; }  If input is in good format, do the verification with transaction, signature and public key(my address).\nThen, if verification passed: continue the transaction creation by calling the blockchain.new_transaction() with transaction without signature as below:\n{ \u0026quot;sender\u0026quot;: \u0026quot;my address\u0026quot;, \u0026quot;recipient\u0026quot;: \u0026quot;someone else's address\u0026quot;, \u0026quot;amount\u0026quot;: 5 }  New transaction will then be added to the transaction pool.\nElse, if verification failed ( signature is invalid ), http 401 (Unauthorized) will be returned.\nIn our implementation, we could have code like this:\n# ... from flask import Flask, jsonify, request # ... @app.route('/transactions/new', methods=['POST']) def new_transaction(): values = request.get_json() # Check that the required fields are in the POST'ed data required = ['sender', 'recipient', 'amount', 'signature'] if not all(k in values for k in required): return 'Missing values', 400 sender = values['sender'] recipient = values['recipient'] amount = values['amount'] signature = values['signature'] if not wallet.verification(sender, recipient, amount, signature): return 'Signature verification failure', 401 # Create a new Transaction blockchain.new_transaction(sender, recipient, amount,) newBlockIndex = blockchain.last_block['index'] + 1 response = {'message': 'Transaction will be added to Block %d' %newBlockIndex } return jsonify(response), 201  4.3 /mine the mining API Our mining endpoint is where the magic happens, and it’s easy. It has to do three things:\n Calculate the Proof of Work (nonce) by calling blockchain.proof_of_work() Reward the miner (us) by adding a transaction granting us 1 coin by calling blockchain.new_transaction() Create the new Block by adding it to the chain by calling blockchain.new_block()  Here the sender address was put \u0026quot;0\u0026quot; , as it\u0026rsquo;s not trasnferred from anyone but being awarded.\n# ... from config import miningReward # ... @app.route('/mine', methods=['GET']) def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block proof = blockchain.proof_of_work(last_block) # We must receive a reward for finding the proof. # The sender is \u0026quot;0\u0026quot; to signify that this node has mined a new coin. blockchain.new_transaction( sender = \u0026quot;0\u0026quot;, recipient = wallet.address, amount = miningReward ) # Create the new Block by adding it to the chain previous_hash = blockchain.hash(last_block) block = blockchain.new_block(proof, previous_hash) response = { 'message': \u0026quot;New Block Created\u0026quot;, 'index': block['index'], 'transactions': block['transactions'], 'proof': block['proof'], 'previous_hash': block['previous_hash'], } return jsonify(response), 200  5. wallet.py address and secret Now let\u0026rsquo;s finished the wallet.py part:\nDuring instatiation, a key pair need to be created:\n ref: http://pythonhosted.org/pycrypto/\n RSA was chosed here to generate the key pair, the bitcoin used a more secure one: the ECDSA. But we are doing the samilar(simplised) process here.\nThe random generator space used in bitcoin is extremely large to enable wallet generation offline possible as the chance is too small, no verification on bitcoin network is needed. While, here we are just using a weak one for learning it.\n5.1 Init for the key pair  Generate secret and address, the private/ public key pair\n __init__\nA rsa instance was generated, then we encoded them with base64 for better format during communication, they were mapped to 64 charactors in both utf-8 and obvirously ASCII without newline charactor. We still used as formater in some other places later.\nfrom Crypto.PublicKey import RSA from Crypto.Signature import PKCS1_v1_5 from Crypto import Random import base64 from Crypto.Hash import MD5 class Wallet: def __init__(self): randomGenerator = Random.new().read self._rsa = RSA.generate(2048, randomGenerator) # export private key self.privateKey = self._rsa.exportKey() self.privateKeyB64 = base64.b64encode(self.privateKey) # export public key self.publicKey = self._rsa.publickey().exportKey() self.publicKeyB64 = base64.b64encode(self.publicKey)  While we would like to support both a newly generated case and the case with a known private key and need to be imported:\nclass Wallet: def __init__(self,privateKeyB64 = None): # If it's an instantiation with provided privateKeyB64, just import it. if privateKeyB64 is not None: privateKeyB64 = privateKeyB64.encode() \\ if type(privateKeyB64) is str \\ else privateKeyB64 self.privateKey, self.privateKeyB64 = base64.b64decode(privateKeyB64), privateKeyB64 # Instatiate _rsa by import private key self._rsa = RSA.importKey(self.privateKey) # If it's a new instance, generate one. else: randomGenerator = Random.new().read self._rsa = RSA.generate(2048, randomGenerator) # export private key self.privateKey = self._rsa.exportKey() self.privateKeyB64 = base64.b64encode(self.privateKey) # export public key self.publicKey = self._rsa.publickey().exportKey() self.publicKeyB64 = base64.b64encode(self.publicKey)  The actual address(public key) and secret (private key) exposed are those encoded with base64.\n@property def address(self): return self.publicKeyB64.decode() @property def secret(self): return self.privateKeyB64.decode()  5.2 Sign a transaction Then let\u0026rsquo;s finish the part for signature:\nsignature() method relays on the generated or imported rsa instance, the signer could be instantiated with PKCS1_v1_5 with rsa instance as the input.\nThe signature method purpose was to sign the transaction with private key to prove the sender of a transaction actually own the sender address.\nAnd here we hashed transaction once with MD5(done before coming into this method, will show later).\nPlease note in bitcoin this whole process are much complex yet basically do different times of changes like( hash, hash the hased value again, get pre-fix of that value, hash … , sign the value with private key, sign with other private key etc\u0026hellip;)\ndef signature(self, hashedTransaction): \u0026quot;\u0026quot;\u0026quot; Sign a hashed transaction :param hashedTransaction: hashed transaction for one wallet address. \u0026quot;\u0026quot;\u0026quot; signer = PKCS1_v1_5.new(self._rsa) signatureRaw = signer.sign(hashedTransaction) return base64.b64encode(signatureRaw)  5.3 Verify a transaction Steps explained:\n Got the transaction from input, hash it the same way before it was signed; Then got the public key (sender address in transaction) to instantiate a verifier for verification; Got signature from input Verify the hashed transaction with verifier(from step 2 with public key) and signature.  @staticmethod def verification(sender, recipient, amount, signature): \u0026quot;\u0026quot;\u0026quot; Verify a transaction for sender's wallet ownership check. :param sender: \u0026lt;str\u0026gt; sender part of transaction to be verified :param recipient: \u0026lt;str\u0026gt; recipient part of transaction to be verified :param amount: \u0026lt;str\u0026gt; amount part of transaction to be verified :param signature: \u0026lt;str\u0026gt; signature to be verified, it was encoded in base64 \u0026quot;\u0026quot;\u0026quot; transaction = \u0026quot;\u0026quot;.join([str(part) for part in [sender, recipient, amount]]).encode() hashedTransaction = MD5.new(transaction) # Instantiate a rsa instance by importing the pub key AKA the sender address _rsa = RSA.importKey(base64.b64decode(sender.encode())) verifier = PKCS1_v1_5.new(_rsa) return verifier.verify( hashedTransaction, base64.b64decode(signature.encode()) )  Now it\u0026rsquo;s all done for our wallet.py.\n6. sigScript.py , sign a transaction Actually in Bitcoin, a sigScript was generated during a transaction, it\u0026rsquo;s not fixed. This generated script make smart contract based on blockchain possible, and is showing high protential to change many things in industry and bussiness world.\nWhile here, we only simpify this sigScript to be fixed, just sign a transaction for ownershipt verification.\nAs I decided to make this signatureScript a command line(CLI), the transaction format to be hased was chosed as simply joined string of each part in a transaction(instead of handling the json format).\n\u0026quot;\u0026quot;\u0026quot; Usage: sigScript.py sender recipient amount privateKeyB64 Options: --help Show this help screen \u0026quot;\u0026quot;\u0026quot; import sys from Crypto.Hash import MD5 from wallet import Wallet sender, recipient, amount, privateKeyB64 = [ argument.encode() for argument in sys.argv[1:] ] transaction = sender + recipient + amount hashedTransaction = MD5.new(transaction) wallet = Wallet(privateKeyB64 = privateKeyB64) signature = wallet.signature(hashedTransaction) print (signature.decode())  For now, we had built a part function of a node.py, and full function of the other parts, let\u0026rsquo;s try test it.\n7. Manully test current work A address/secret pair is only generated during a node instance running, let\u0026rsquo;s run it to see.\n7.1 some preparation works To help get the secret, let\u0026rsquo;s add this endpoint to node.py\n@app.route('/secret', methods=['GET']) def get_secret(): response = { 'message': \u0026quot;secret sent in console...\u0026quot; } secret = wallet.secret print (\u0026quot;┌─────────────────────────────────────────┐\u0026quot;) print (\u0026quot;│ secret base64 output begins │\u0026quot;) print (\u0026quot;└─────────────────────────────────────────┘\u0026quot;) print (secret) print (\u0026quot;┌─────────────────────────────────────────┐\u0026quot;) print (\u0026quot;│ secret base64 output ends │\u0026quot;) print (\u0026quot;└─────────────────────────────────────────┘\u0026quot;) return jsonify(response), 200  7.2 some clients I created some clients to interact with our blockchain:\n$ tree -L 1 | egrep -v \u0026quot;.py\u0026quot; . ├── mine ├── rc ├── register ├── resolve ├── sendTransaction ├── transactions ├── chain └── secret  They are not magic things but bash scripts. And to make our experient easier and with more fun!\n7.2.1 How to use: a. run rc to initiate\n$ . rc  It will ask the node.py address, just type/paste it and enter. For example\nhttp://localhost:5000  b. run mine to mine from the session with rc initiated.\nFor example:\nc. run other clients like secret\nFor example:\n7.2.2 Install dependencies $ source venv/bin/activate $ pip install flask $ pip install requests $ easy_install pycrypto  7.3 Run node.py, and test! $ python node.py  7.3.1 Supported commands till now    Command Explanation and help     . rc Activate a client for a node.py instance.   mine Mine a block.   chain Fetch current chain.   transactions Fetch current transaction pool.   secret Fetch secret, the private key in base64.   sigScript.py sender recipient amount privateKeyB64 Sign the transaction.   sendTransaction Send transaction.    With above commands, we could do blockchain mining, transaction signning, transactions etc.\n8. Consensus This is very cool. We’ve got a basic Blockchain that accepts transactions and allows us to mine new Blocks. But the whole point of Blockchains is that they should be decentralized. And if they’re decentralized, how on earth do we ensure that they all reflect the same chain? This is called the problem of Consensus, and we’ll have to implement a Consensus Algorithm if we want more than one node in our network.\n8.1 Registering new Nodes Before we can implement a Consensus Algorithm, we need a way to let a node know about neighbouring nodes on the network. Each node on our network should keep a registry of other nodes on the network. Thus, we’ll need some more endpoints:\n /nodes to fetch all neighbor nodes. /nodes/register to accept a list of new nodes in the form of URLs. /nodes/resolve to implement our Consensus Algorithm, which resolves any conflicts—to ensure a node has the correct chain.  The json data to be posted to node for registering a neighbor could be designed like below, to identify with the full schema of http URL.\n{ \u0026quot;nodes\u0026quot;: [\u0026quot;http://localhost:5001\u0026quot;] }   To better handle the string for URL, we could use urlparse(python2) , in python3 it\u0026rsquo;s urllib.parse . To store nodes data, we are using set() to avoid duplicated nodes being added.  blockchain.py\nfrom urllib.parse import urlparse # ... class Blockchain: def __init__(self): # ... self.nodes = set() # ... def register_node(self, address): \u0026quot;\u0026quot;\u0026quot; Add a new node to the list of nodes :param address: Address of node. Eg. 'http://192.168.0.5:5000' \u0026quot;\u0026quot;\u0026quot; parsed_url = urlparse(address) if parsed_url.netloc: self.nodes.add(parsed_url.netloc) elif parsed_url.path: # Accepts an URL without scheme like '192.168.0.5:5000'. self.nodes.add(parsed_url.path) else: raise ValueError('Invalid URL')  netloc and path are used to detect different types of urls it handles.\nIn [145]: parsed_url = urlparse(\u0026quot;http://localhost:5000\u0026quot;) In [146]: parsed_url.netloc Out[146]: 'localhost:5000' In [147]: parsed_url.path Out[147]: '' In [148]: parsed_url = urlparse(\u0026quot;localhost:5000\u0026quot;) In [149]: parsed_url.path Out[149]: 'localhost:5000' In [150]: parsed_url.netloc Out[150]: ''  8.2 Consensus Algorithm As mentioned, a conflict is when one node has a different chain to another node. To resolve this, we’ll make the rule that the longest valid chain is authoritative. In other words, the longest chain on the network is the de-facto one. Using this algorithm, we reach Consensus amongst the nodes in our network.\nAnd for now, we will enable node to communicate with other node, as they only have http access, the way to make that happen is to use requests.\nvalid_chain() is to valid any chain, the self is for calling method in self.\nvalid_chain() is responsible for checking if a chain is valid by looping through each block and verifying both the hash and the proof.\nimport requests class Blockchain: # ... def valid_chain(self, chain): \u0026quot;\u0026quot;\u0026quot; Determine if a given blockchain is valid :param chain: A blockchain :return: True if valid, False if not \u0026quot;\u0026quot;\u0026quot; last_block = chain[0] current_index = 1 while current_index \u0026lt; len(chain): block = chain[current_index] # Check that the hash of the block is correct if block['previous_hash'] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block['proof'], block['proof'], self.hash(last_block)): return False last_block = block current_index += 1 return True  resolve_conflicts is to replace larger valid chain to current chain on the node.\nresolve_conflicts() is a method which loops through all our neighbouring nodes, downloads their chains and verifies them using the above method. If a valid chain is found, whose length is greater than ours, we replace ours.\nclass Blockchain: # ... def resolve_conflicts(self): \u0026quot;\u0026quot;\u0026quot; This is our consensus algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: True if our chain was replaced, False if not \u0026quot;\u0026quot;\u0026quot; neighbours = self.nodes #print (str(self.nodes)) new_chain = None # We're only looking for chains longer than ours max_length = len(self.chain) print (\u0026quot;self.chain length: \u0026quot; + str(max_length)) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get('http://'+node+'/chain') print (\u0026quot;response.status_code: \u0026quot; + str(response.status_code)) if response.status_code == 200: length = response.json()['length'] chain = response.json()['chain'] print (\u0026quot;node length: \u0026quot; + str(length)) # Check if the length is longer and the chain is valid if length \u0026gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain print (\u0026quot;self.chain:\u0026quot; + str(self.chain)) return True return False  8.3 endpoints of /nodes/* node.py\n# ... @app.route('/nodes', methods=['GET']) def all_nodes(): response = { 'nodes': blockchain.nodes, 'length': len(blockchain.nodes), } return jsonify(response), 200 @app.route('/nodes/register', methods=['POST']) def register_nodes(): values = request.get_json() nodes = values.get('nodes') if nodes is None: return \u0026quot;Error: Please supply a valid list of nodes\u0026quot;, 400 for node in nodes: blockchain.register_node(node) response = { 'message': 'New nodes have been added', 'total_nodes': list(blockchain.nodes), } return jsonify(response), 201 @app.route('/nodes/resolve', methods=['GET']) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { 'message': 'Our chain was replaced', 'new_chain': blockchain.chain } else: response = { 'message': 'Our chain is authoritative', 'chain': blockchain.chain } return jsonify(response), 200  9 Run multiple nodes! if __name__ == '__main__': from argparse import ArgumentParser parser = ArgumentParser() parser.add_argument('-p', '--port', default=5000, type=int, help='port to listen on') args = parser.parse_args() port = args.port app.run(debug=True, host='0.0.0.0', port=port)  Now it supports --port \u0026lt;port\u0026gt; options, below two terminal output is showing how two nodes were started with different ports.\n(env) python node.py * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 277-203-847  (env)python node.py --port 5001 * Running on http://0.0.0.0:5001/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 277-203-847  10 Try final version till now Below are supported commands I built(calling the endpoint we created).\n   Command Explanation and help     . rc Activate a client for a node.py instance.   mine Mine a block.   chain Fetch current chain.   transactions Fetch current transaction pool.   secret Fetch secret, the private key in base64.   sigScript.py sender recipient amount privateKeyB64 Sign the transaction.   sendTransaction Send transaction.   register Add/register a neighbor node.   resolve Sync with neighbors, resolve conflicts.   nodes Query all neighbor nodes.    Hope you will enjoy and have fun with this blockchain :-).\n $ tree . ├── blockchain.py ├── chain ├── config.py ├── mine ├── node.py ├── nodes ├── rc ├── register ├── resolve ├── secret ├── sendTransaction ├── sigScript.py ├── task-2-blockchain.md ├── transactions └── wallet.py  ref: http://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html\nref: https://docs.python.org/3/library/base64.html\nref: http://pythonhosted.org/pycrypto/toc-Crypto.Signature.PKCS1_v1_5-module.html\nref: https://www.zhihu.com/question/23608006\n"
},
{
	"uri": "http://pyCamp.swdp.me/tasks/task-0/",
	"title": "Build a cli Tool",
	"tags": [],
	"description": "",
	"content": " Let\u0026rsquo;s create tool to parse a nova/nova.conf file in order to get expected values, like my_ip , if what virt_type etc..\nWhat needs to be done?\n A function to handle the actual input. make it handle arguments from command line Let\u0026rsquo;s make it professional Use docopt to simplify it!  reference: http://docopt.org\n deal with excel/csv etc\u0026hellip;\n [TOC]\nAfter class task:\n create a cli tool  Input processing reference: https://docs.openstack.org/ocata/config-reference/compute/nova-conf-samples.html\nThe input is something like:\n[DEFAULT] # LOGS/STATE logdir=/var/log/nova state_path=/var/lib/nova lock_path=/var/lock/nova rootwrap_config=/etc/nova/rootwrap.conf # SCHEDULER compute_scheduler_driver=nova.scheduler.filter_scheduler.FilterScheduler # VOLUMES # configured in cinder.conf # COMPUTE compute_driver=libvirt.LibvirtDriver instance_name_template=instance-%08x api_paste_config=/etc/nova/api-paste.ini # COMPUTE/APIS: if you have separate configs for separate services # this flag is required for both nova-api and nova-compute allow_resize_to_same_host=True # APIS osapi_compute_extension=nova.api.openstack.compute.contrib.standard_extensions ec2_dmz_host=192.168.206.130 s3_host=192.168.206.130 # RABBITMQ rabbit_host=192.168.206.130 # GLANCE image_service=nova.image.glance.GlanceImageService # NETWORK network_manager=nova.network.manager.FlatDHCPManager force_dhcp_release=True dhcpbridge_flagfile=/etc/nova/nova.conf firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver # Change my_ip to match each host my_ip=192.168.206.130 public_interface=eth0 vlan_interface=eth0 flat_network_bridge=br100 flat_interface=eth0 # NOVNC CONSOLE novncproxy_base_url=http://192.168.206.130:6080/vnc_auto.html # Change vncserver_proxyclient_address and vncserver_listen to match each compute host vncserver_proxyclient_address=192.168.206.130 vncserver_listen=192.168.206.130 # AUTHENTICATION auth_strategy=keystone [keystone_authtoken] auth_host = 127.0.0.1 auth_port = 35357 auth_protocol = http admin_tenant_name = service admin_user = nova admin_password = nova signing_dirname = /tmp/keystone-signing-nova # GLANCE [glance] api_servers=192.168.206.130:9292 # DATABASE [database] connection=mysql+pymysql://nova:yourpassword@192.168.206.130/nova # LIBVIRT [libvirt] virt_type=qemu  Let\u0026rsquo;s simplify it for showing in one screen:\n[DEFAULT] # NETWORK network_manager=nova.network.manager.FlatDHCPManager force_dhcp_release=True dhcpbridge_flagfile=/etc/nova/nova.conf firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver # Change my_ip to match each host my_ip=192.168.206.130 public_interface=eth0 vlan_interface=eth0 flat_network_bridge=br100 flat_interface=eth0 # LIBVIRT [libvirt] virt_type=qemu  Load it as a string:\n\u0026quot;\u0026quot;\u0026quot; is used for multi-line string\nIn [1]: input = \u0026quot;\u0026quot;\u0026quot; ...: [DEFAULT] ...: ...: # NETWORK ...: network_manager=nova.network.manager.FlatDHCPManager ...: force_dhcp_release=True ...: dhcpbridge_flagfile=/etc/nova/nova.conf ...: firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver ...: # Change my_ip to match each host ...: my_ip=192.168.206.130 ...: public_interface=eth0 ...: vlan_interface=eth0 ...: flat_network_bridge=br100 ...: flat_interface=eth0 ...: # LIBVIRT ...: [libvirt] ...: virt_type=qemu\u0026quot;\u0026quot;\u0026quot; In [4]: print (input) [DEFAULT] # NETWORK network_manager=nova.network.manager.FlatDHCPManager force_dhcp_release=True dhcpbridge_flagfile=/etc/nova/nova.conf firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver # Change my_ip to match each host my_ip=192.168.206.130 public_interface=eth0 vlan_interface=eth0 flat_network_bridge=br100 flat_interface=eth0 # LIBVIRT [libvirt] virt_type=qemu  Let\u0026rsquo;s do some pre-processing on it.\nIn [5]: inputList = input.split(\u0026quot;\\n\u0026quot;) In [6]: print (inputList) ['', '[DEFAULT]', '', '# NETWORK', 'network_manager=nova.network.manager.FlatDHCPManager', 'force_dhcp_release=True', 'dhcpbridge_flagfile=/etc/nova/nova.conf', 'firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver', '# Change my_ip to match each host', 'my_ip=192.168.206.130', 'public_interface=eth0', 'vlan_interface=eth0', 'flat_network_bridge=br100', 'flat_interface=eth0', '# LIBVIRT', '[libvirt]', 'virt_type=qemu'] In [7]: type(inputList) Out[7]: list  Now we have a list, where all items come from the lines of nova.conf, let\u0026rsquo;s do something for it!\nStep 1 the main function We could build a function to parse specific parameter name and return the value ;-).\ndef parse(par,inputList): #magic things return valueForThePar  Then let\u0026rsquo;s do the magic :\ndef parse(par,inputList): valueForThePar = \u0026quot;oops: there is no \u0026quot; + par + \u0026quot; found.\u0026quot; for line in inputList: line = line.strip().split(\u0026quot;=\u0026quot;) if par == line[0]: valueForThePar = line[1] return valueForThePar  Let\u0026rsquo;s run it:\nIn [12]: def parse(par,inputList): ...: valueForThePar = \u0026quot;oops: there is no \u0026quot; + par + \u0026quot; found.\u0026quot; ...: for line in inputList: ...: line = line.strip().split(\u0026quot;=\u0026quot;) ...: if par == line[0]: ...: valueForThePar = line[1] ...: return valueForThePar ...: In [13]: parse(\u0026quot;neutron\u0026quot;,inputList) Out[13]: '#Err: there is no neutron found.' In [14]: parse(\u0026quot;virt_type\u0026quot;,inputList) Out[14]: 'qemu'  Seems working yet easy, correct?\n But we need a real program to handle a file as input instead of a string coming from copy paste, how could we do that? How could we let the program know which parameter need to be parsed?  Step 2 Input Parse arguments Let\u0026rsquo;s use sys.argv, which is a list of the argument variables passed during program calling.\nFor example, let\u0026rsquo;s write this test-argv.py:\nimport sys print (sys.argv[0])  run it:\n$ python3 test-argv.py ['test-argv.py']  Confused? How about this?\nimport sys print (sys.argv[0:])  run it with different arguments:\n$ python3 test-argv.py ['test-argv.py'] $ python3 test-argv.py a b c ['test-argv.py', 'a', 'b', 'c']  Now with this power we could design our tool like this:\npython3 our-cool-tool-file-name.py --input \u0026lt;path-to-input-file\u0026gt; --par \u0026lt;par\u0026gt;\nThen it comes to the hardest part, naming the tool. Let\u0026rsquo;s call it novaConfParser.py ;-).\nLet\u0026rsquo;s write novaConfParser.py, it\u0026rsquo;s something like:\ndef parseArgVars(): pass # parse input in list type def parse(par,inputList): valueForThePar = \u0026quot;oops: there is no \u0026quot; + par + \u0026quot; found.\u0026quot; for line in inputList: line = line.strip().split(\u0026quot;=\u0026quot;) line = [item.strip() for item in line] if par == line[0]: valueForThePar = line[1] return valueForThePar # ... something in between # main process def main(): parseArgVars() print (parse(par,inputList)) main()  For the part of parseArgVars(), let\u0026rsquo;s make it as below, which just parsed the arguments of filePath , par, and validate the arguments, if it\u0026rsquo;s not validate, stop everything but provide the help info.\nimport sys argVars = sys.argv[1:] argFormatErrorFlag = True helpInfo = \u0026quot;\u0026quot;\u0026quot;Usage: novaConfParser.py [--input \u0026lt;path-to-input-file\u0026gt;] [--par \u0026lt;par\u0026gt;] Options: --help Show this help screen. Examples: python3 novaConfParser.py --input /nova/nova.conf --par my_ip \u0026quot;\u0026quot;\u0026quot; # parse parseArgVars def parseArgVars(argVars, flag): # init for filePath, par filePath, par = \u0026quot;\u0026quot;, \u0026quot;\u0026quot; if len(argVars) == 4: if \u0026quot;--input\u0026quot; and \u0026quot;--par\u0026quot; in [argVars[0], argVars[2]]: # if in order: --input x --par y filePath, par = argVars[1], argVars[3] # argFormatErrorFlag is valid now flag = False # switch order if needed, in order: --par x --input y if argVars[0] != \u0026quot;--input\u0026quot;: filePath, par = par, filePath return flag, filePath , par def parse(par,inputList): valueForThePar = \u0026quot;oops: there is no \u0026quot; + par + \u0026quot; found.\u0026quot; for line in inputList: line = line.strip().split(\u0026quot;=\u0026quot;) if par == line[0]: valueForThePar = line[1] return valueForThePar # main process def main(argVars, argFormatErrorFlag): # parse arguments and validate them argFormatErrorFlag, filePath, par = parseArgVars(argVars, argFormatErrorFlag) # in case argFormatErrorFlag is True, end and print the help info if argFormatErrorFlag: print (helpInfo) # End function without raise errors return None # ... something in between \u0026lt;--------- print (parse(par,inputList)) # run main function main(argVars, argFormatErrorFlag)  Read file Till now we have:\n arguments parsed in the begining by parseArgVars #... something in between \u0026lt;--------- nova.conf \u0026rsquo;s handler parse() to deal with a list() input file  What the only something left here is to read the nova.conf file and return it as list:\ndef readInputFile(path): # do things return aListSplitedByLines  And it\u0026rsquo;s easy:\ndef readInputFile(path): with open(path) as file: fileStr = file.read() return fileStr.split(\u0026quot;\\n\u0026quot;)  A working tool was done! And now we have the tool done:\nimport sys argVars = sys.argv[1:] argFormatErrorFlag = True helpInfo = \u0026quot;\u0026quot;\u0026quot;Usage: novaConfParser.py [--input \u0026lt;path-to-input-file\u0026gt;] [--par \u0026lt;par\u0026gt;] Options: --help Show this help screen. Examples: python3 novaConfParser.py --input /nova/nova.conf --par my_ip \u0026quot;\u0026quot;\u0026quot; # parse parseArgVars def parseArgVars(argVars, flag): # init for filePath, par filePath, par = str(), str() if len(argVars) == 4: if \u0026quot;--input\u0026quot; and \u0026quot;--par\u0026quot; in [argVars[0], argVars[2]]: # if in order: --input x --par y filePath, par = argVars[1], argVars[3] # argFormatErrorFlag is valid now flag = False # switch order if needed, in order: --par x --input y if argVars[0] != \u0026quot;--input\u0026quot;: filePath, par = par, filePath return flag, filePath , par def parse(par,inputList): valueForThePar = \u0026quot;oops: there is no \u0026quot; + par + \u0026quot; found.\u0026quot; for line in inputList: line = line.strip().split(\u0026quot;=\u0026quot;) if par == line[0]: valueForThePar = line[1] return valueForThePar def readInputFile(path): with open(path) as file: fileStr = file.read() return fileStr.split(\u0026quot;\\n\u0026quot;) # main process def main(argVars, argFormatErrorFlag): # parse arguments and validate them argFormatErrorFlag, filePath, par = parseArgVars(argVars, argFormatErrorFlag) # in case argFormatErrorFlag is True, end and print the help info if argFormatErrorFlag: print (helpInfo) # End function without raise errors return None # Read file as a list inputList = readInputFile(filePath) # Build final output with parse() output = parse(par,inputList) # do the output print (output) # run main function main(argVars, argFormatErrorFlag)  Can we make life easier? Basically our tool is like:\n handling arguments parsed in the beginning by parseArgVars Read file The function do handle main logic  With the tool to enable more complex things possible, the parseArgVars part could be much crazy below are options you could use:\n argparse ( https://docs.python.org/3/library/argparse.html ) docopt ( http://docopt.org )  Let\u0026rsquo;s take docopt as an example\ndocopt example ref: https://github.com/docopt/docopt/blob/master/examples/\nnovaConfParser_V2.py:\n\u0026quot;\u0026quot;\u0026quot;Usage: novaConfParser_V2.py [--input \u0026lt;path-to-input-file\u0026gt;] [--par \u0026lt;par\u0026gt;] Options: --help Show this help screen. Examples: python3 novaConfParser.py --input /nova/nova.conf --par my_ip \u0026quot;\u0026quot;\u0026quot; from docopt import docopt if __name__ == '__main__': arguments = docopt(__doc__, version='0.1.1rc') print(arguments)  Let\u0026rsquo;s verify it:\nIt\u0026rsquo;s doing thins magically good, we could see in this single example, arguments is a dict, which is actually covering the argument parse and validation.\n$ python3 novaConfParser_V2.py {'--input': False, '--par': False, '\u0026lt;par\u0026gt;': None, '\u0026lt;path-to-input-file\u0026gt;': None} $ python3 novaConfParser_V2.py --input /nova/nova.conf --par my_ip {'--input': True, '--par': True, '\u0026lt;par\u0026gt;': 'my_ip', '\u0026lt;path-to-input-file\u0026gt;': '/nova/nova.conf'} $ python3 novaConfParser_V2.py --help Usage: novaConfParser_V2.py [--input \u0026lt;path-to-input-file\u0026gt;] [--par \u0026lt;par\u0026gt;] Options: -h --help Show this help screen. Examples: python3 novaConfParser_V2.py --input /nova/nova.conf --par my_ip $ python3 novaConfParser_V2.py --version 0.1.1rc  We could directly use it as below:\nIn [7]: arguments[\u0026quot;--input\u0026quot;] Out[7]: True In [8]: arguments = {'--input': True, ...: '--par': True, ...: '\u0026lt;par\u0026gt;': 'my_ip', ...: '\u0026lt;path-to-input-file\u0026gt;': '/nova/nova.conf'} ...: In [9]: arguments[\u0026quot;--input\u0026quot;] Out[9]: True In [10]: arguments['\u0026lt;path-to-input-file\u0026gt;'] Out[10]: '/nova/nova.conf'  What else?  Shebang ref: https://en.wikipedia.org/wiki/Shebang_%28Unix%293 virtualenv parse from or write to json, excel, xml, csv etc ?  built-in library: https://docs.python.org/3/library/index.html Awesome Python: https://github.com/vinta/awesome-python  Doing things for servers? paramiko / ansible exceptions: http://www.runoob.com/python/python-exceptions.html  "
},
{
	"uri": "http://pyCamp.swdp.me/tasks/",
	"title": "Tasks",
	"tags": [],
	"description": "",
	"content": " The Workshop Part Tasks driven learning We designed some typical tasks, let\u0026rsquo;s learn by creating different things.\n"
},
{
	"uri": "http://pyCamp.swdp.me/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Python Boot-camp [TOC]\nOverview Workshop Video \\\\***REMOVED***\\Usertmp$\\pyCamp\\Video\nWorkshop Keynotes and Codes \\\\drive.swdp.me\\learning\\pyCamp\\codesAndKeynotes\n###\n   Time Task Outcome Reference     W0 Prepare environment, join the slack channel for discussion or learn from historical discussion. A ready to use python envrionment. This document   W1 Task 0, build a cli tool Learn basic concept, build a command line tool, run it.     Task 1, build a web application. Reach more python concepts, build a website, build a webapp with same function of task     Task 2, build a blockchain. Start building your first OOP python project, organize a bigger flask project.    W2 Task 3, build a microservice project TBD     Task 4, build an openstack project TBD     Preparation Slack channel: #py-camp\nEnvironment setup a Linux VM (Ubuntu) will do, reference: https://askubuntu.com/questions/142549/how-to-install-ubuntu-on-virtualbox\n 3G ram 1-2 CPU  A just working editor Sublime text/Atom/VS code will do the job, I was using Sublime Text 3\nreference: http://tipsonubuntu.com/2017/05/30/install-sublime-text-3-ubuntu-16-04-official-way/\nHow to run your python code? Preparation:\nto avoid anything stops you from the beginning let\u0026rsquo;s just use python3 directly, if you know how to use virtualenv, use it instead, if you don\u0026rsquo;t know virtualenv do it as below.\n install pip for python3, upgrade it then:  $ sudo apt-get install python3-pip -y $ sudo pip3 install --upgrade pip   install ipython as your python playground console  $ sudo pip3 install ipython  Hello world! from ipython\nYou could use it in one terminal for debugging for always, it\u0026rsquo;s better than the python console in some ways.\n$ ipython3 Python 3.5.2 (default, Nov 23 2017, 16:37:01) Type 'copyright', 'credits' or 'license' for more information IPython 6.2.1 -- An enhanced Interactive Python. Type '?' for help. In [1]: print (\u0026quot;hello world!\u0026quot;) hello world! In [2]: exit $  Hello world! from your first python script\n$ cat hello_world.py print (\u0026quot;Hello world!\u0026quot;) $ python3 hello_world.py Hello world!  Congratulations! One more step left:\nGo through the tutor reference: https://docs.python.org/3/tutorial/\nor: http://www.pythondoc.com/pythontutorial3/\nTasks Task 0, create a cli tool Let\u0026rsquo;s create tool to parse a nova/nova.conf file in order to get expected values, like my_ip , if what virt_type etc..\nWhat needs to be done?\n A function to handle the actual input. make it handle arguments from command line Let\u0026rsquo;s make it professional Use docopt to simplify it! reference: http://docopt.org  Further study:\n Shebang ref: https://en.wikipedia.org/wiki/Shebang_%28Unix%293 virtualenv parse from or write to json, excel, xml, csv etc ?  built-in library: https://docs.python.org/3/library/index.html Awesome Python: https://github.com/vinta/awesome-python  Doing things for servers? paramiko / ansible exceptions: http://www.runoob.com/python/python-exceptions.html  After class task:\n create a cli tool  Task 1, create a website This task is to create a web app with flask, following the flask-mega-tutorial first three chapters.\nreference:\n innoSearch project: https://github.com/littlewey/yet-another-GSC-C-lighthouse ldif-compare: https://github.com/littlewey/ldif-compare  After class task:\n create a web tool, which could reuse the main function of Task 0.  Task 2, create a blockchain  Our task demo is highly reusing code and even some words in https://hackernoon.com/learn-blockchains-by-building-one-117428612f46 (many thanks to Daniel van Flymen), some enhancements were added on top of that here including sender address verification, and some script clients.\n In this task, we will create a simple part of blockchain application like bitcoin.\nThings we will go though:\n Some object-oriented programing (not just call class from a python module) http request flask as http api endpoints  After class task:\n create the blockchain app following the tutorial, study the code (as explained in class), if possible improve it.  Task 3, create a big project(micro service enabled)  haproxy, etcd, k8s etc\u0026hellip;\n To be continued in next presenting week.\nTask 4, create a tool based on oslo  Openstack related\n To be continued in next presenting week.\n"
},
{
	"uri": "http://pyCamp.swdp.me/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://pyCamp.swdp.me/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]